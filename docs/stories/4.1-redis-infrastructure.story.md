# Story 4.1: Set Up Redis Infrastructure

**Epic:** Marketplace Resilience System v2
**ID:** STORY-4.1
**Status:** Draft
**Complexity:** M (8 points)
**Time Estimate:** 3-4 days

---

## Story

Set up Redis as persistent job queue for marketplace analysis Phase 1 creation. Includes local development setup, cloud configuration for production, and connection management.

**Dependencies:** None

---

## Acceptance Criteria

1. ✅ Redis running locally (Docker container or local instance)
2. ✅ Redis configured in production (AWS ElastiCache or equivalent)
3. ✅ Connection pooling implemented (max 50 concurrent)
4. ✅ Authentication credentials in `.env` (separate dev/prod)
5. ✅ Health check endpoint: `GET /api/health/redis`
6. ✅ Connection retry logic with exponential backoff
7. ✅ Monitoring metrics exported (connections, commands, latency)

---

## Scope

### IN (What we're doing)
- Create Redis client with connection pooling
- Local Docker setup for development
- AWS ElastiCache configuration template
- Health check endpoint
- Exponential backoff retry logic
- Integration tests

### OUT (What we're NOT doing)
- Redis cluster setup (single-instance sufficient)
- Redis persistence configuration (beyond defaults)
- Redis memory optimization
- Redis sentinel/failover (Phase 3)

---

## Implementation Tasks

- [ ] Create `lib/redis-client.ts` with connection pooling
- [ ] Add Redis configuration to `.env.example` and `.env.local`
- [ ] Implement health check middleware
- [ ] Add Docker Compose configuration for local Redis
- [ ] Create AWS ElastiCache Terraform config for production
- [ ] Write integration tests for connection/reconnection
- [ ] Document Redis setup in CONTRIBUTING.md
- [ ] Update story File List

---

## Acceptance Test

```bash
npm run dev
# In another terminal:
curl http://localhost:3000/api/health/redis
# Expected: { "status": "connected", "latency": "2ms" }
```

---

## Dev Notes

**Implementation considerations:**
- Use ioredis for connection pooling and retry logic
- Connection pool size: 50 for development, 100 for production
- Retry logic: exponential backoff (base: 1s, max: 30s)
- Health check should test actual Redis command (PING)
- Credentials should use separate variables for dev/prod

**Testing approach:**
- Unit tests for client creation
- Integration tests with real Redis (Docker in test)
- Connection failure scenarios
- Pooling behavior under load

---

## Testing

**Manual Testing:**
1. Start dev server with Redis running
2. Hit health check endpoint
3. Verify metrics are exported
4. Check logs for connection events

**Automated Testing:**
- Connection pool creation
- Health check endpoint
- Retry logic with mocked connection failures
- Connection count limits

---

## File List

*After implementation, list all files created/modified:*

- [ ] lib/redis-client.ts
- [ ] .env.example
- [ ] docker-compose.yml
- [ ] terraform/redis.tf (if applicable)
- [ ] app/api/health/redis/route.ts
- [ ] __tests__/redis-client.test.ts

---

## Dev Agent Record

**Status:** Pending
**Assigned To:** @dev (Dex)
**Current Task:** Waiting for assignment

### Implementation Checkboxes
- [ ] Code implementation complete
- [ ] Unit tests written
- [ ] Integration tests passing
- [ ] Documentation updated
- [ ] Ready for QA review

### Debug Log
(Will be updated during implementation)

### Completion Notes
(Will be added when story completes)

---

## QA Results

(Will be populated by @qa Quinn)

---

## Change Log

- Created: 2026-02-23 (Marathon Phase 2)
- Status: Draft → Ready (pending @po validation)

---

## Story Metrics

| Metric | Value |
|--------|-------|
| Story Points | 8 |
| Time Estimate | 3-4 days |
| Complexity | Medium |
| Priority | High (dependency for 4.2-4.4) |
| Risk | Low |
